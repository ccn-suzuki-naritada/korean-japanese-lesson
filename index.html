<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>éŸ“å›½èªå­¦ç¿’ãƒšãƒ¼ã‚¸ï¼ˆHTML+JSï½œã‚«ã‚¿ã‚«ãƒŠãƒ«ãƒ“å¯¾å¿œï¼‰</title>
  <style>
    :root{--bg:#f7f7fb;--card:#fff;--ink:#111;--muted:#6b7280;--border:#e5e7eb;--ok:#def7e5;--ng:#fde2e2;--warn:#fff2cc}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(#fff,#f3f4f6);color:var(--ink);font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1100px;margin:0 auto;padding:16px 16px 56px}
    h1{font-size:clamp(20px,3.8vw,28px);margin:0 0 6px}
    h2{font-size:18px;margin:0 0 8px}
    .muted{color:var(--muted)}
    .row{display:grid;gap:16px}
    @media(min-width:960px){.row{grid-template-columns:1fr 1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 8px rgba(0,0,0,.04)}
    textarea{width:100%;min-height:160px;resize:vertical;border:1px solid var(--border);border-radius:12px;padding:10px;font-size:15px;line-height:1.5}
    select,input[type="text"],input[type="url"],input[type="email"]{border:1px solid var(--border);border-radius:10px;padding:8px 10px;font-size:14px}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:999px;background:#fff;padding:8px 12px;cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .kbd{min-width:36px;height:44px;border:1px solid var(--border);background:#fff;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;box-shadow:0 1px 3px rgba(0,0,0,.05)}
    .kbd .main{font-size:18px;line-height:18px}
    .kbd .sub{font-size:10px;color:var(--muted);line-height:10px}
    .keys{display:flex;gap:6px;justify-content:center}
    .stack{display:flex;flex-direction:column;gap:6px}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#fff}
    .ruby{padding:10px;border-radius:12px;background:#f7fafc;line-height:2;font-size:18px;word-break:break-word}
    .diff{padding:10px;border-radius:12px;background:#f7fafc;line-height:2;font-size:18px;word-break:break-word;min-height:72px;border:1px dashed var(--border)}
    .ok{background:var(--ok)} .ng{background:var(--ng)} .warn{background:var(--warn)} .strike{text-decoration:line-through;opacity:.7}
    .danger{color:#b91c1c}
    .success{color:#0f766e}
    .right{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .seg{display:inline-flex;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    .seg button{padding:6px 10px;border:0;background:#fff}
    .seg button[aria-pressed="true"]{background:#111;color:#fff}
    .small{font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="right" style="justify-content:space-between;align-items:flex-end;margin-bottom:12px">
      <div>
        <h1>éŸ“å›½èªå­¦ç¿’ãƒšãƒ¼ã‚¸ï¼ˆHTML + JS / 1ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰</h1>
        <div class="muted small">ãƒ«ãƒ“ã¯ <b>ã‚«ã‚¿ã‚«ãƒŠè¡¨è¨˜</b>ã€‚æ•°å­—ã¯å¯èƒ½ãªã‚‰ <b>æ¼¢æ•°è©ï¼ˆéŸ“å›½èªã®èª­ã¿ï¼‰</b>ã§ãƒ«ãƒ“åŒ–ã—ã¾ã™ã€‚</div>
      </div>
      <div class="right">
        <button class="btn" id="copyPageUrlBtn">ã“ã®ãƒšãƒ¼ã‚¸ã®URLã‚’ã‚³ãƒ”ãƒ¼</button>
      </div>
    </header>

    <!-- ç¿»è¨³ UI -->
    <section class="row">
      <div class="card stack">
        <div class="right">
          <h2 style="margin-right:auto">åŸæ–‡å…¥åŠ›</h2>
          <div class="right">
            <label class="pill">From
              <select id="sourceLang">
                <option value="auto">è‡ªå‹•</option>
                <option value="ja">æ—¥æœ¬èª</option>
                <option value="ko">éŸ“å›½èª</option>
                <option value="en">è‹±èª</option>
                <option value="zh">ä¸­å›½èª</option>
                <option value="de">ãƒ‰ã‚¤ãƒ„èª</option>
                <option value="fr">ãƒ•ãƒ©ãƒ³ã‚¹èª</option>
                <option value="es">ã‚¹ãƒšã‚¤ãƒ³èª</option>
              </select>
            </label>
            <span class="muted">â†’</span>
            <label class="pill">To
              <select id="targetLang">
                <option value="ja">æ—¥æœ¬èª</option>
                <option value="ko">éŸ“å›½èª</option>
                <option value="en">è‹±èª</option>
                <option value="zh">ä¸­å›½èª</option>
                <option value="de">ãƒ‰ã‚¤ãƒ„èª</option>
                <option value="fr">ãƒ•ãƒ©ãƒ³ã‚¹èª</option>
                <option value="es">ã‚¹ãƒšã‚¤ãƒ³èª</option>
              </select>
            </label>
            <button class="btn" id="translateBtn">ç¿»è¨³</button>
          </div>
        </div>
        <textarea id="sourceText" placeholder="ã“ã“ã«åŸæ–‡ã‚’å…¥åŠ›"></textarea>
        <div class="small muted">è‡ªå‹•ãƒ«ãƒ“ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰ï¼š</div>
        <div id="rubySource" class="ruby"></div>
      </div>
      <div class="card stack">
        <h2>ç¿»è¨³çµæœ</h2>
        <textarea id="translatedText" placeholder="ç¿»è¨³çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>
        <div class="small muted">è‡ªå‹•ãƒ«ãƒ“ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰ï¼š</div>
        <div id="rubyTranslated" class="ruby"></div>
      </div>
    </section>

    <!-- æ‰‹å…¥åŠ› & ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ -->
    <section class="row" style="margin-top:16px">
      <div class="card stack">
        <div class="right" style="justify-content:space-between">
          <h2>éŸ“å›½èªã®æ‰‹å…¥åŠ›</h2>
          <label class="right small"><input type="checkbox" id="useVirtualKeyboard" checked> ä»®æƒ³ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚’ä½¿ã†</label>
        </div>
        <textarea id="manualText" placeholder="ã“ã“ã«æ‰‹å…¥åŠ›" readonly></textarea>
        <div class="small muted">è‡ªå‹•ãƒ«ãƒ“ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰ï¼š</div>
        <div id="rubyManual" class="ruby"></div>
        <div id="keyboard" class="stack" style="margin-top:6px">
          <div class="right" style="justify-content:space-between">
            <div class="small muted">å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰</div>
            <div class="right">
              <div class="seg" role="tablist" aria-label="keyboard-mode">
                <button id="modeHangul" aria-pressed="true">í•œê¸€</button>
                <button id="modeABC" aria-pressed="false">ABC</button>
                <button id="mode123" aria-pressed="false">123</button>
              </div>
              <button class="btn" id="shiftBtn">Shift</button>
            </div>
          </div>
          <div class="stack">
            <div class="keys" id="row1"></div>
            <div class="keys" id="row2"></div>
            <div class="keys" id="row3"></div>
          </div>
        </div>
      </div>
      <div class="card stack">
        <h2>åŸæ–‡ï¼ç¿»è¨³ ã¨ æ‰‹å…¥åŠ› ã®æ¯”è¼ƒ</h2>
        <div class="small muted">æ¯”è¼ƒå¯¾è±¡ã¯ã€Œç¿»è¨³çµæœã€ãŒã‚ã‚Œã°å„ªå…ˆã€ãªã‘ã‚Œã°ã€ŒåŸæ–‡ã€ã§ã™ã€‚</div>
        <div id="diffOut" class="diff"></div>
        <div id="firstError" class="small"></div>
        <div class="right">
          <button class="btn" id="clearManual">æ‰‹å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢</button>
          <button class="btn" id="copyManual">æ‰‹å…¥åŠ›ã‚’ã‚³ãƒ”ãƒ¼</button>
        </div>
      </div>
    </section>

    <!-- ç¿»è¨³APIã®é¸æŠï¼ˆç„¡æ–™ç³»ï¼‰ -->
    <section class="card stack" style="margin-top:16px">
      <h2>ç¿»è¨³APIã®é¸æŠ</h2>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <label class="pill">Provider
          <select id="provider">
            <option value="libre">LibreTranslate</option>
            <option value="mymemory">MyMemory</option>
          </select>
        </label>
        <div></div>
      </div>
      <div id="cfg-libre" style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <label>LibreTranslate Base URL
          <input id="libreBase" type="url" placeholder="https://libretranslate.com" value="https://libretranslate.com"/>
        </label>
        <label>API Keyï¼ˆä»»æ„ï¼å¿…è¦ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ï¼‰
          <input id="libreKey" type="text" placeholder="ç©ºã§OKï¼ˆè‡ªå·±ãƒ›ã‚¹ãƒˆã‚„éµä¸è¦ã®ãƒŸãƒ©ãƒ¼ï¼‰" />
        </label>
      </div>
      <div id="cfg-mymemory" style="display:none;grid-template-columns:1fr 1fr;gap:8px">
        <label>Contact Emailï¼ˆä»»æ„ / de ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰
          <input id="mmEmail" type="email" placeholder="user@example.comï¼ˆé«˜é »åº¦åˆ©ç”¨æ™‚ã«æ¨å¥¨ï¼‰" />
        </label>
        <div></div>
      </div>
      <div class="small muted">â€» ç„¡æ–™APIã¯ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚„å“è³ªã®ã°ã‚‰ã¤ããŒã‚ã‚Šã¾ã™ã€‚å®‰å®šé‹ç”¨ã¯ LibreTranslate ã®<strong>è‡ªå·±ãƒ›ã‚¹ãƒˆ</strong>ãŒãŠã™ã™ã‚ã§ã™ã€‚</div>
    </section>
  </div>

  <script>
    /**
     * =============================================
     * Hangul Core: decompose/compose + Katakana RT
     * =============================================
     */
    const Hangul = (() => {
      // --- Unicode indices
      const S_BASE=0xAC00, L_BASE=0x1100, V_BASE=0x1161, T_BASE=0x11A7;
      const L_COUNT=19, V_COUNT=21, T_COUNT=28, N_COUNT=V_COUNT*T_COUNT;
      const L_LIST=["ã„±","ã„²","ã„´","ã„·","ã„¸","ã„¹","ã…","ã…‚","ã…ƒ","ã……","ã…†","ã…‡","ã…ˆ","ã…‰","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
      const V_LIST=["ã…","ã…","ã…‘","ã…’","ã…“","ã…”","ã…•","ã…–","ã…—","ã…˜","ã…™","ã…š","ã…›","ã…œ","ã…","ã…","ã…Ÿ","ã… ","ã…¡","ã…¢","ã…£"];
      const T_LIST=["","ã„±","ã„²","ã„³","ã„´","ã„µ","ã„¶","ã„·","ã„¹","ã„º","ã„»","ã„¼","ã„½","ã„¾","ã„¿","ã…€","ã…","ã…‚","ã…„","ã……","ã…†","ã…‡","ã…ˆ","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
      const V_COMBINE={"ã…—ã…":"ã…˜","ã…—ã…":"ã…™","ã…—ã…£":"ã…š","ã…œã…“":"ã…","ã…œã…":"ã…","ã…œã…£":"ã…Ÿ","ã…¡ã…£":"ã…¢"};
      const T_COMBINE={"ã„±ã……":"ã„³","ã„´ã…ˆ":"ã„µ","ã„´ã…":"ã„¶","ã„¹ã„±":"ã„º","ã„¹ã…":"ã„»","ã„¹ã…‚":"ã„¼","ã„¹ã……":"ã„½","ã„¹ã…Œ":"ã„¾","ã„¹ã…":"ã„¿","ã„¹ã…":"ã…€","ã…‚ã……":"ã…„"};
      const T_SPLIT={"ã„³":["ã„±","ã……"],"ã„µ":["ã„´","ã…ˆ"],"ã„¶":["ã„´","ã…"],"ã„º":["ã„¹","ã„±"],"ã„»":["ã„¹","ã…"],"ã„¼":["ã„¹","ã…‚"],"ã„½":["ã„¹","ã……"],"ã„¾":["ã„¹","ã…Œ"],"ã„¿":["ã„¹","ã…"],"ã…€":["ã„¹","ã…"],"ã…„":["ã…‚","ã……"]};

      function isHangulSyllable(ch){ const cp=ch.codePointAt(0); return cp>=0xAC00 && cp<=0xD7A3; }

      function decomposeSyllableToJamo(syll){
        if(!isHangulSyllable(syll)) return [syll];
        const sIndex = syll.codePointAt(0) - S_BASE;
        const lIndex = Math.floor(sIndex / N_COUNT);
        const vIndex = Math.floor((sIndex % N_COUNT) / T_COUNT);
        const tIndex = sIndex % T_COUNT;
        const arr=[L_LIST[lIndex], V_LIST[vIndex]]; if(tIndex>0) arr.push(T_LIST[tIndex]);
        return arr;
      }

      // --- Compose from jamo stream (for virtual keyboard)
      function composeFromJamoStream(stream){
        const out=[]; let l=null,v=null,t=null;
        const flush=()=>{ if(l&&v){ const li=L_LIST.indexOf(l),vi=V_LIST.indexOf(v),ti=t?T_LIST.indexOf(t):0; if(li>=0&&vi>=0&&ti>=0){ out.push(String.fromCodePoint(S_BASE + (li*N_COUNT) + (vi*T_COUNT) + ti)); } else { if(l)out.push(l); if(v)out.push(v); if(t)out.push(t); } } else { if(l)out.push(l); if(v)out.push(v); if(t)out.push(t);} l=v=t=null; };
        const chars = Array.from(stream);
        for(let i=0;i<chars.length;i++){
          const ch=chars[i]; const isV = V_LIST.includes(ch); const isL = L_LIST.includes(ch); const isT = T_LIST.includes(ch) && ch!=="";
          if(isV){
            if(!l&&!v&&!t){ l="ã…‡"; v=ch; continue; }
            if(l&&v&&!t){ const merged=V_COMBINE[v+ch]; if(merged){ v=merged; continue; } flush(); l="ã…‡"; v=ch; t=null; continue; }
            if(l&&v&&t){ const split=T_SPLIT[t]; flush(); if(split){ l=split[1]; v=ch; t=null; } else { l=t; v=ch; t=null; } continue; }
            if(l&&!v&&!t){ v=ch; continue; }
            flush(); l="ã…‡"; v=ch; t=null; continue;
          }
          if(isL||isT){
            if(!l&&!v&&!t){ l=ch; continue; }
            if(l&&!v&&!t){ out.push(l); l=ch; continue; }
            if(l&&v&&!t){ if(!T_LIST.includes(ch) || T_LIST.indexOf(ch)<=0){ flush(); l=ch; continue; } t=ch; continue; }
            if(l&&v&&t){ const merged=T_COMBINE[t+ch]; if(merged){ t=merged; continue; } flush(); l=ch; continue; }
            flush(); l=ch; continue;
          }
          flush(); out.push(ch);
        }
        flush(); return out.join("");
      }

      // --- Sino-Korean number reading (hangul)
      const DIGITS=['ì˜','ì¼','ì´','ì‚¼','ì‚¬','ì˜¤','ìœ¡','ì¹ ','íŒ”','êµ¬'];
      const SMALL_UNITS=['','ì‹­','ë°±','ì²œ'];
      const BIG_UNITS=['','ë§Œ','ì–µ','ì¡°','ê²½'];
      function stripLeadingZeros(numStr){ let i=0; while(i<numStr.length-1 && numStr[i]==='0'){ i++; } return numStr.slice(i); }
      function numberToHangulSino(nStr){
        const cleaned = stripLeadingZeros(nStr);
        if(cleaned==='' || /^0+$/.test(nStr)) return 'ì˜';
        const rev = cleaned.split('').reverse();
        const out=[];
        for(let block=0; block*4<rev.length; block++){
          const chunk = rev.slice(block*4, block*4+4);
          let chunkStr='';
          for(let i=chunk.length-1;i>=0;i--){
            const d = parseInt(chunk[i],10);
            if(d===0) continue;
            const unit = SMALL_UNITS[i];
            const digitStr = (unit && d===1) ? '' : DIGITS[d];
            chunkStr += digitStr + unit;
          }
          if(chunkStr){ chunkStr += BIG_UNITS[block]; out.unshift(chunkStr); }
        }
        return out.join('');
      }

      // --- Hangul -> Katakana (simplified)
      const ROW = {
        'ã„±':{base:'g', gem:false}, 'ã…‹':{base:'k', gem:false}, 'ã„²':{base:'k', gem:true},
        'ã„´':{base:'n', gem:false}, 'ã„·':{base:'d', gem:false}, 'ã…Œ':{base:'t', gem:false}, 'ã„¸':{base:'t', gem:true},
        'ã„¹':{base:'r', gem:false}, 'ã…':{base:'m', gem:false}, 'ã…‚':{base:'b', gem:false}, 'ã…':{base:'p', gem:false}, 'ã…ƒ':{base:'p', gem:true},
        'ã……':{base:'s', gem:false}, 'ã…†':{base:'s', gem:true}, 'ã…‡':{base:'v', gem:false},
        'ã…ˆ':{base:'j', gem:false}, 'ã…Š':{base:'ch',gem:false}, 'ã…‰':{base:'j', gem:true}, 'ã…':{base:'h', gem:false},
      };
      function cvToKana(base, v){
        const V2 = {
          'ã…':{kana:{g:'ã‚¬',k:'ã‚«',n:'ãƒŠ',d:'ãƒ€',t:'ã‚¿',r:'ãƒ©',m:'ãƒ',b:'ãƒ',p:'ãƒ‘',s:'ã‚µ',j:'ã‚¸ãƒ£',ch:'ãƒãƒ£',h:'ãƒ',v:'ã‚¢'}},
          'ã…':{kana:{g:'ã‚²',k:'ã‚±',n:'ãƒ',d:'ãƒ‡',t:'ãƒ†',r:'ãƒ¬',m:'ãƒ¡',b:'ãƒ™',p:'ãƒš',s:'ã‚»',j:'ã‚¸ã‚§',ch:'ãƒã‚§',h:'ãƒ˜',v:'ã‚¨'}},
          'ã…‘':{kana:{g:'ã‚®ãƒ£',k:'ã‚­ãƒ£',n:'ãƒ‹ãƒ£',d:'ã‚¸ãƒ£',t:'ãƒãƒ£',r:'ãƒªãƒ£',m:'ãƒŸãƒ£',b:'ãƒ“ãƒ£',p:'ãƒ”ãƒ£',s:'ã‚·ãƒ£',j:'ã‚¸ãƒ£',ch:'ãƒãƒ£',h:'ãƒ’ãƒ£',v:'ãƒ¤'}},
          'ã…’':{kana:{g:'ã‚®ã‚§',k:'ã‚­ã‚§',n:'ãƒ‹ã‚§',d:'ã‚¸ã‚§',t:'ãƒã‚§',r:'ãƒªã‚§',m:'ãƒŸã‚§',b:'ãƒ“ã‚§',p:'ãƒ”ã‚§',s:'ã‚·ã‚§',j:'ã‚¸ã‚§',ch:'ãƒã‚§',h:'ãƒ’ã‚§',v:'ã‚¤ã‚§'}},
          'ã…“':{kana:{g:'ã‚´',k:'ã‚³',n:'ãƒ',d:'ãƒ‰',t:'ãƒˆ',r:'ãƒ­',m:'ãƒ¢',b:'ãƒœ',p:'ãƒ',s:'ã‚½',j:'ã‚¸ãƒ§',ch:'ãƒãƒ§',h:'ãƒ›',v:'ã‚ª'}},
          'ã…”':{kana:{g:'ã‚²',k:'ã‚±',n:'ãƒ',d:'ãƒ‡',t:'ãƒ†',r:'ãƒ¬',m:'ãƒ¡',b:'ãƒ™',p:'ãƒš',s:'ã‚»',j:'ã‚¸ã‚§',ch:'ãƒã‚§',h:'ãƒ˜',v:'ã‚¨'}},
          'ã…•':{kana:{g:'ã‚®ãƒ§',k:'ã‚­ãƒ§',n:'ãƒ‹ãƒ§',d:'ã‚¸ãƒ§',t:'ãƒãƒ§',r:'ãƒªãƒ§',m:'ãƒŸãƒ§',b:'ãƒ“ãƒ§',p:'ãƒ”ãƒ§',s:'ã‚·ãƒ§',j:'ã‚¸ãƒ§',ch:'ãƒãƒ§',h:'ãƒ’ãƒ§',v:'ãƒ¨'}},
          'ã…–':{kana:{g:'ã‚®ã‚§',k:'ã‚­ã‚§',n:'ãƒ‹ã‚§',d:'ã‚¸ã‚§',t:'ãƒã‚§',r:'ãƒªã‚§',m:'ãƒŸã‚§',b:'ãƒ“ã‚§',p:'ãƒ”ã‚§',s:'ã‚·ã‚§',j:'ã‚¸ã‚§',ch:'ãƒã‚§',h:'ãƒ’ã‚§',v:'ã‚¤ã‚§'}},
          'ã…—':{kana:{g:'ã‚´',k:'ã‚³',n:'ãƒ',d:'ãƒ‰',t:'ãƒˆ',r:'ãƒ­',m:'ãƒ¢',b:'ãƒœ',p:'ãƒ',s:'ã‚½',j:'ã‚¸ãƒ§',ch:'ãƒãƒ§',h:'ãƒ›',v:'ã‚ª'}},
          'ã…˜':{kana:{g:'ã‚°ã‚¡',k:'ã‚¯ã‚¡',n:'ãƒŒã‚¡',d:'ãƒ‰ã‚¡',t:'ãƒˆã‚¡',r:'ãƒ«ã‚¡',m:'ãƒ ã‚¡',b:'ãƒ–ã‚¡',p:'ãƒ—ã‚¡',s:'ã‚¹ã‚¡',j:'ã‚¸ãƒ¥ã‚¡',ch:'ãƒãƒ¥ã‚¡',h:'ãƒ›ã‚¡',v:'ãƒ¯'}},
          'ã…™':{kana:{g:'ã‚°ã‚§',k:'ã‚¯ã‚§',n:'ãƒŒã‚§',d:'ãƒ‰ã‚§',t:'ãƒˆã‚§',r:'ãƒ«ã‚§',m:'ãƒ ã‚§',b:'ãƒ–ã‚§',p:'ãƒ—ã‚§',s:'ã‚¹ã‚§',j:'ã‚¸ãƒ¥ã‚§',ch:'ãƒãƒ¥ã‚§',h:'ãƒ›ã‚§',v:'ã‚¦ã‚§'}},
          'ã…š':{kana:{g:'ã‚°ã‚§',k:'ã‚¯ã‚§',n:'ãƒã‚§',d:'ãƒ‰ã‚§',t:'ãƒˆã‚§',r:'ãƒ­ã‚§',m:'ãƒ¢ã‚§',b:'ãƒœã‚§',p:'ãƒã‚§',s:'ã‚½ã‚§',j:'ã‚¸ãƒ§ã‚§',ch:'ãƒãƒ§ã‚§',h:'ãƒ›ã‚§',v:'ã‚¦ã‚§'}},
          'ã…›':{kana:{g:'ã‚®ãƒ§',k:'ã‚­ãƒ§',n:'ãƒ‹ãƒ§',d:'ã‚¸ãƒ§',t:'ãƒãƒ§',r:'ãƒªãƒ§',m:'ãƒŸãƒ§',b:'ãƒ“ãƒ§',p:'ãƒ”ãƒ§',s:'ã‚·ãƒ§',j:'ã‚¸ãƒ§',ch:'ãƒãƒ§',h:'ãƒ’ãƒ§',v:'ãƒ¨'}},
          'ã…œ':{kana:{g:'ã‚°',k:'ã‚¯',n:'ãƒŒ',d:'ãƒ‰ã‚¥',t:'ãƒˆã‚¥',r:'ãƒ«',m:'ãƒ ',b:'ãƒ–',p:'ãƒ—',s:'ã‚¹',j:'ã‚¸ãƒ¥',ch:'ãƒãƒ¥',h:'ãƒ•',v:'ã‚¦'}},
          'ã…':{kana:{g:'ã‚°ã‚©',k:'ã‚¯ã‚©',n:'ãƒŒã‚©',d:'ãƒ‰ã‚©',t:'ãƒˆã‚©',r:'ãƒ«ã‚©',m:'ãƒ ã‚©',b:'ãƒ–ã‚©',p:'ãƒ—ã‚©',s:'ã‚¹ã‚©',j:'ã‚¸ãƒ¥ã‚©',ch:'ãƒãƒ¥ã‚©',h:'ãƒ›ã‚©',v:'ã‚¦ã‚©'}},
          'ã…':{kana:{g:'ã‚°ã‚§',k:'ã‚¯ã‚§',n:'ãƒŒã‚§',d:'ãƒ‰ã‚§',t:'ãƒˆã‚§',r:'ãƒ«ã‚§',m:'ãƒ ã‚§',b:'ãƒ–ã‚§',p:'ãƒ—ã‚§',s:'ã‚¹ã‚§',j:'ã‚¸ãƒ¥ã‚§',ch:'ãƒãƒ¥ã‚§',h:'ãƒ›ã‚§',v:'ã‚¦ã‚§'}},
          'ã…Ÿ':{kana:{g:'ã‚°ã‚£',k:'ã‚¯ã‚£',n:'ãƒŒã‚£',d:'ãƒ‰ã‚£',t:'ãƒˆã‚£',r:'ãƒ«ã‚£',m:'ãƒ ã‚£',b:'ãƒ–ã‚£',p:'ãƒ—ã‚£',s:'ã‚¹ã‚£',j:'ã‚¸',ch:'ãƒ',h:'ãƒ•ã‚£',v:'ã‚¦ã‚£'}},
          'ã… ':{kana:{g:'ã‚®ãƒ¥',k:'ã‚­ãƒ¥',n:'ãƒ‹ãƒ¥',d:'ãƒ‡ãƒ¥',t:'ãƒ†ãƒ¥',r:'ãƒªãƒ¥',m:'ãƒŸãƒ¥',b:'ãƒ“ãƒ¥',p:'ãƒ”ãƒ¥',s:'ã‚·ãƒ¥',j:'ã‚¸ãƒ¥',ch:'ãƒãƒ¥',h:'ãƒ’ãƒ¥',v:'ãƒ¦'}},
          'ã…¡':{kana:{g:'ã‚°',k:'ã‚¯',n:'ãƒŒ',d:'ãƒ‰ã‚¥',t:'ãƒˆã‚¥',r:'ãƒ«',m:'ãƒ ',b:'ãƒ–',p:'ãƒ—',s:'ã‚¹',j:'ã‚¸',ch:'ãƒãƒ¥',h:'ãƒ•',v:'ã‚¦'}},
          'ã…¢':{kana:{g:'ã‚°ã‚£',k:'ã‚¯ã‚£',n:'ãƒŒã‚£',d:'ãƒ‰ã‚£',t:'ãƒˆã‚£',r:'ãƒ«ã‚£',m:'ãƒ ã‚£',b:'ãƒ–ã‚£',p:'ãƒ—ã‚£',s:'ã‚¹ã‚£',j:'ã‚¸',ch:'ãƒ',h:'ãƒ•ã‚£',v:'ã‚¦ã‚£'}},
          'ã…£':{kana:{g:'ã‚®',k:'ã‚­',n:'ãƒ‹',d:'ãƒ‡ã‚£',t:'ãƒ†ã‚£',r:'ãƒª',m:'ãƒŸ',b:'ãƒ“',p:'ãƒ”',s:'ã‚·',j:'ã‚¸',ch:'ãƒ',h:'ãƒ’',v:'ã‚¤'}},
        };
        const entry = V2[v];
        return entry ? (entry.kana[base] || 'ãƒ»') : 'ãƒ»';
      }
      function tToKana(t){
        switch(t){
          case '': return '';
          case 'ã„±': case 'ã„²': case 'ã…‹': case 'ã„³': case 'ã„º': case 'ã…†': case 'ã……': case 'ã…ˆ': case 'ã…Š': case 'ã…Œ': case 'ã…': case 'ã„·': return 'ãƒƒ';
          case 'ã…‚': case 'ã…„': case 'ã„¼': case 'ã„¿': return 'ãƒƒ';
          case 'ã„´': case 'ã…‡': return 'ãƒ³';
          case 'ã…': return 'ãƒ ';
          case 'ã„¹': return 'ãƒ«';
          default: return '';
        }
      }
      function syllableToKatakana(syll){
        const parts = decomposeSyllableToJamo(syll);
        const L = parts[0], V = parts[1], T = parts[2]||'';
        if(!V) return syll;
        const row = ROW[L] || ROW['ã…‡'];
        const kana = cvToKana(row.base, V);
        const tail = tToKana(T);
        return (row.gem? 'ãƒƒ' : '') + kana + tail;
      }

      // text -> Katakana RT (with numeric reading)
      function isDigit(ch){ return ch>='0' && ch<='9'; }
      const UNIT_KANA = { 'ë…„':'ãƒ‹ãƒ§ãƒ³','ì›”':'ã‚¦ã‚©ãƒ«','ì¼':'ã‚¤ãƒ«','ì‹œ':'ã‚·','ë¶„':'ãƒ—ãƒ³','ì´ˆ':'ãƒãƒ§' };
      function textToKatakanaRT(text){
        const arr=[...text]; const out=[]; let i=0;
        while(i<arr.length){
          const ch = arr[i];
          if(isHangulSyllable(ch)){
            let j=i, buf='';
            while(j<arr.length && isHangulSyllable(arr[j])){ buf += syllableToKatakana(arr[j]); j++; }
            out.push(buf); i=j; continue;
          }
          if(isDigit(ch)){
            let j=i, num='';
            while(j<arr.length && isDigit(arr[j])){ num+=arr[j]; j++; }
            let unitKana='';
            const p2 = (arr[j]||'') + (arr[j+1]||'');
            const p1 = (arr[j]||'');
            if(UNIT_KANA[p2]){ unitKana = UNIT_KANA[p2]; j+=2; }
            else if(UNIT_KANA[p1]){ unitKana = UNIT_KANA[p1]; j+=1; }
            const hangNum = numberToHangulSino(num);
            const kanaNum = [...hangNum].map(c=> isHangulSyllable(c)? syllableToKatakana(c) : c).join('');
            out.push(kanaNum + unitKana); i=j; continue;
          }
          out.push(ch); i++;
        }
        return out.join('');
      }

      function buildRubyFragmentKatakana(text){
        const frag=document.createDocumentFragment();
        const arr=[...text]; let i=0;
        while(i<arr.length){
          const ch=arr[i];
          const isNum = (ch>='0' && ch<='9');
          if(isHangulSyllable(ch) || isNum){
            let j=i, token='';
            if(isHangulSyllable(ch)){
              while(j<arr.length && isHangulSyllable(arr[j])){ token+=arr[j]; j++; }
            } else { // number token + optional unit
              while(j<arr.length && (arr[j]>='0' && arr[j]<='9')){ token+=arr[j]; j++; }
              const p2=(arr[j]||'')+(arr[j+1]||''); const p1=(arr[j]||'');
              if(UNIT_KANA[p2]){ token+=p2; j+=2; }
              else if(UNIT_KANA[p1]){ token+=p1; j+=1; }
            }
            const ruby=document.createElement('ruby');
            const rb=document.createElement('rb'); rb.textContent=token; ruby.appendChild(rb);
            const rt=document.createElement('rt'); rt.textContent=textToKatakanaRT(token); rt.style.fontSize='12px'; rt.style.color='#6b7280'; ruby.appendChild(rt);
            ruby.style.marginRight='2px'; ruby.className='align-middle';
            frag.appendChild(ruby); i=j; continue;
          }
          frag.appendChild(document.createTextNode(ch)); i++;
        }
        return frag;
      }

      return { composeFromJamoStream, buildRubyFragmentKatakana };
    })();

    /**
     * ============================
     * Virtual Keyboard (ë‘ë²Œì‹ / ABC / 123)
     * ============================
     */
    const Keyboard = (() => {
      const BASE = { q:"ã…‚", w:"ã…ˆ", e:"ã„·", r:"ã„±", t:"ã……", y:"ã…›", u:"ã…•", i:"ã…‘", o:"ã…", p:"ã…”", a:"ã…", s:"ã„´", d:"ã…‡", f:"ã„¹", g:"ã…", h:"ã…—", j:"ã…“", k:"ã…", l:"ã…£", z:"ã…‹", x:"ã…Œ", c:"ã…Š", v:"ã…", b:"ã… ", n:"ã…œ", m:"ã…¡" };
      const SHIFT = { q:"ã…ƒ", w:"ã…‰", e:"ã„¸", r:"ã„²", t:"ã…†", o:"ã…’", p:"ã…–" };
      const ROWS = [["q","w","e","r","t","y","u","i","o","p"],["a","s","d","f","g","h","j","k","l"],["z","x","c","v","b","n","m","âŒ«","âµ","â†µ"]];

      const ABC_ROWS = [["q","w","e","r","t","y","u","i","o","p"],["a","s","d","f","g","h","j","k","l"],["z","x","c","v","b","n","m","âŒ«","âµ","â†µ"]];
      const NUM_ROWS = [["1","2","3","4","5","6","7","8","9","0"],["-","/",":",";","(",")","$","&","@"],[".",",","?","!","'","\"","âŒ«","âµ","â†µ"]];
      return { BASE, SHIFT, ROWS, ABC_ROWS, NUM_ROWS };
    })();

    /**
     * ============================
     * Diff Utility (è»½é‡)
     * ============================
     */
    const Diff = (() => {
      function diff(a,b){
        const A=(a||"").normalize("NFC"); const B=(b||"").normalize("NFC");
        const max=Math.max(A.length,B.length); const nodes=[]; let firstError=null;
        for(let i=0;i<max;i++){
          const ca=A[i], cb=B[i]; const span=document.createElement('span');
          if(ca===cb){ span.className='ok'; span.textContent=cb||''; }
          else { if(firstError===null) firstError=i; if(cb===undefined){ span.className='ng strike'; span.textContent=ca; } else if(ca===undefined){ span.className='warn'; span.textContent=cb; } else { span.className='warn'; span.style.textDecoration='underline'; span.style.textDecorationColor='#ef4444'; span.textContent=cb; } }
          nodes.push(span);
        }
        return {nodes, firstErrorIndex:firstError};
      }
      return { diff };
    })();

    /**
     * ============================
     * Translation Providers (ç„¡æ–™ç³»)
     * ============================
     */
    const Providers = (() => {
      function trimEndSlash(url){ return url.endsWith('/') ? url.slice(0,-1) : url; }
      async function libreTranslate(baseUrl, apiKey, text, source, target){
        const payload = { q:text, source:source||"auto", target:target||"ja" };
        if(apiKey) payload.api_key = apiKey;
        const r = await fetch(trimEndSlash(String(baseUrl))+"/translate",{ method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(payload) });
        if(!r.ok) throw new Error("LibreTranslate å‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ: "+r.status);
        const j = await r.json(); return j.translatedText || "";
      }
      async function myMemory(text, source, target, email){
        const url = new URL("https://api.mymemory.translated.net/get");
        url.searchParams.set("q", text);
        url.searchParams.set("langpair", (source||"auto")+"|"+(target||"ja"));
        if(email) url.searchParams.set("de", email);
        const r = await fetch(url.toString()); if(!r.ok) throw new Error("MyMemory å‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ: "+r.status);
        const j = await r.json(); return (j && j.responseData && j.responseData.translatedText) ? j.responseData.translatedText : "";
      }
      return { libreTranslate, myMemory };
    })();

    // DOM refs
    const el = {
      sourceLang: document.getElementById('sourceLang'), targetLang: document.getElementById('targetLang'),
      sourceText: document.getElementById('sourceText'), translatedText: document.getElementById('translatedText'), translateBtn: document.getElementById('translateBtn'),
      rubySource: document.getElementById('rubySource'), rubyTranslated: document.getElementById('rubyTranslated'), rubyManual: document.getElementById('rubyManual'),
      manualText: document.getElementById('manualText'), useVirtualKeyboard: document.getElementById('useVirtualKeyboard'), keyboard: document.getElementById('keyboard'),
      row1: document.getElementById('row1'), row2: document.getElementById('row2'), row3: document.getElementById('row3'),
      shiftBtn: document.getElementById('shiftBtn'), diffOut: document.getElementById('diffOut'), firstError: document.getElementById('firstError'),
      clearManual: document.getElementById('clearManual'), copyManual: document.getElementById('copyManual'),
      provider: document.getElementById('provider'), cfgLibre: document.getElementById('cfg-libre'), cfgMyMem: document.getElementById('cfg-mymemory'),
      libreBase: document.getElementById('libreBase'), libreKey: document.getElementById('libreKey'), mmEmail: document.getElementById('mmEmail'),
      copyPageUrlBtn: document.getElementById('copyPageUrlBtn'),
      modeHangul: document.getElementById('modeHangul'), modeABC: document.getElementById('modeABC'), mode123: document.getElementById('mode123'),
    };

    // state
    let shiftOn=false; let jamoBuffer=""; let kbMode='hangul';

    // init
    renderKeyboard(); renderAllRubies(); renderDiff();

    // events
    el.copyPageUrlBtn.addEventListener('click', () => navigator.clipboard.writeText(location.href));
    el.translateBtn.addEventListener('click', doTranslate);
    el.sourceText.addEventListener('input', () => { renderAllRubies(); renderDiff(); });
    el.translatedText.addEventListener('input', () => { renderAllRubies(); renderDiff(); });
    el.manualText.addEventListener('input', () => { renderAllRubies(); renderDiff(); });

    el.useVirtualKeyboard.addEventListener('change', () => {
      const useKB=el.useVirtualKeyboard.checked; el.manualText.readOnly=useKB; el.keyboard.style.display=useKB?'':'none';
      if(!useKB){ el.manualText.value = Hangul.composeFromJamoStream(jamoBuffer); }
      renderAllRubies(); renderDiff();
    });

    el.shiftBtn.addEventListener('click', () => { shiftOn=!shiftOn; el.shiftBtn.style.background = shiftOn? '#111': '#fff'; el.shiftBtn.style.color = shiftOn? '#fff':'#111'; renderKeyboard(); });
    el.clearManual.addEventListener('click', () => { jamoBuffer=""; el.manualText.value=""; renderAllRubies(); renderDiff(); });
    el.copyManual.addEventListener('click', () => navigator.clipboard.writeText(getManualText()));

    el.provider.addEventListener('change', () => { const v=el.provider.value; el.cfgLibre.style.display = v==='libre'?'':'none'; el.cfgMyMem.style.display = v==='mymemory'?'':'none'; });

    el.modeHangul.addEventListener('click', ()=>setMode('hangul'));
    el.modeABC.addEventListener('click', ()=>setMode('abc'));
    el.mode123.addEventListener('click', ()=>setMode('num'));
    function setMode(mode){ kbMode=mode; el.modeHangul.setAttribute('aria-pressed', mode==='hangul'); el.modeABC.setAttribute('aria-pressed', mode==='abc'); el.mode123.setAttribute('aria-pressed', mode==='num'); renderKeyboard(); }

    // keyboard render
    const KeyboardLayouts = Keyboard;
    function renderKeyboard(){
      const rows=[el.row1,el.row2,el.row3]; rows.forEach(r=>r.innerHTML='');
      let layout;
      if(kbMode==='hangul') layout = KeyboardLayouts.ROWS;
      else if(kbMode==='abc') layout = KeyboardLayouts.ABC_ROWS;
      else layout = KeyboardLayouts.NUM_ROWS;
      layout.forEach((rowKeys, ri)=>{
        rowKeys.forEach(k=>{
          const btn=document.createElement('button'); btn.className='kbd'; btn.type='button';
          btn.addEventListener('click', ()=>handleKey(k));
          const main=document.createElement('div'); main.className='main';
          const sub=document.createElement('div'); sub.className='sub';
          if(k==='âŒ«'||k==='âµ'||k==='â†µ'){ main.textContent=k; }
          else if(kbMode==='hangul'){
            const lower=k.toLowerCase(); const base=KeyboardLayouts.BASE[lower]; const sh=KeyboardLayouts.SHIFT[lower]; main.textContent=(shiftOn && sh)? sh: base; sub.textContent=k;
          } else if(kbMode==='abc'){
            main.textContent = shiftOn? k.toUpperCase() : k.toLowerCase(); sub.textContent=k;
          } else { main.textContent = k; }
          btn.appendChild(main); btn.appendChild(sub); rows[ri].appendChild(btn);
        });
      });
    }

    function handleKey(k){
      if(k==='âŒ«'){ if(kbMode==='hangul'){ jamoBuffer=jamoBuffer.slice(0,-1); el.manualText.value = Hangul.composeFromJamoStream(jamoBuffer); } else { el.manualText.value = el.manualText.value.slice(0,-1); } renderAllRubies(); renderDiff(); return; }
      if(k==='âµ'){ if(kbMode==='hangul'){ jamoBuffer+=' '; el.manualText.value = Hangul.composeFromJamoStream(jamoBuffer); } else { el.manualText.value += ' '; } renderAllRubies(); renderDiff(); return; }
      if(k==='â†µ'){ if(kbMode==='hangul'){ jamoBuffer+='\n'; el.manualText.value = Hangul.composeFromJamoStream(jamoBuffer); } else { el.manualText.value += '\n'; } renderAllRubies(); renderDiff(); return; }
      if(kbMode==='hangul'){
        const lower=k.toLowerCase(); const base=KeyboardLayouts.BASE[lower]; const sh=KeyboardLayouts.SHIFT[lower]; const jamo=(shiftOn&&sh)? sh: base; if(jamo){ jamoBuffer+=jamo; el.manualText.value = Hangul.composeFromJamoStream(jamoBuffer); }
      } else if(kbMode==='abc'){
        const ch = shiftOn? k.toUpperCase() : k.toLowerCase(); el.manualText.value += ch;
      } else { el.manualText.value += k; }
      renderAllRubies(); renderDiff(); renderKeyboard();
    }

    // ruby render
    function renderAllRubies(){
      el.rubySource.innerHTML=''; el.rubySource.appendChild(Hangul.buildRubyFragmentKatakana(el.sourceText.value));
      el.rubyTranslated.innerHTML=''; el.rubyTranslated.appendChild(Hangul.buildRubyFragmentKatakana(el.translatedText.value));
      el.rubyManual.innerHTML=''; el.rubyManual.appendChild(Hangul.buildRubyFragmentKatakana(getManualText()));
    }
    function getManualText(){ return el.useVirtualKeyboard.checked ? el.manualText.value : el.manualText.value; }

    // diff render
    const DiffUtil = Diff;
    function renderDiff(){
      const compareTarget = (el.translatedText.value && el.translatedText.value.trim().length>0) ? el.translatedText.value : el.sourceText.value;
      const res = DiffUtil.diff(compareTarget, getManualText());
      el.diffOut.innerHTML=''; res.nodes.forEach(n=>el.diffOut.appendChild(n));
      if(res.firstErrorIndex!==null){ el.firstError.className='small danger'; el.firstError.textContent='æœ€åˆã®èª¤ã‚Šä½ç½®ï¼š'+(res.firstErrorIndex+1)+' æ–‡å­—ç›®'; }
      else { el.firstError.className='small success'; el.firstError.textContent='ã™ã¹ã¦ä¸€è‡´ã—ã¦ã„ã¾ã™ ğŸ‰'; }
    }

    // translation call
    async function doTranslate(){
      const text=el.sourceText.value||''; if(!text.trim()){ alert('åŸæ–‡ãŒç©ºã§ã™'); return; }
      const src=el.sourceLang.value||'auto'; const tgt=el.targetLang.value||'ja'; const provider=el.provider.value;
      try{ setBusy(true); let out=''; if(provider==='libre'){ out=await Providers.libreTranslate(el.libreBase.value, el.libreKey.value, text, src, tgt); } else { out=await Providers.myMemory(text, src, tgt, el.mmEmail.value); } el.translatedText.value=out; renderAllRubies(); renderDiff(); }
      catch(err){ alert(String(err&&err.message||err)); }
      finally{ setBusy(false); }
    }
    function setBusy(b){ el.translateBtn.disabled=b; el.translateBtn.textContent=b?'ç¿»è¨³ä¸­â€¦':'ç¿»è¨³'; }
  </script>
</body>
</html>
